-   Assets are being linked using their actual filenames. It'll probably be
    better to use indexes per level to link the assets. Either that or just use
    mapped IDs.
    -   The main thing with per level indexing is keeping loaded assets between
        levels and keeping their index

-   Indices may actually be fine, but texture arrays are going to use indexes.
    Maybe have a map of strings to index?
-   If the string mapping is too slow, the asset manager can just generate
    indices that the models themselves hold or the strings can be hashed at
    runtime and only store the indices

-   TextureArrays per level can be implemented instead of switching resources
    every render

-   Sparse Arrays for the ECS is likely necessary to safe on memory and prevent
    updating unused components
    -   Tracking the active entity indices would be helpful in preventing
        unecessary updates as well if Sparse Arrays will not be used

-   Camera needs to collide with world

-   Asset building

-   The parameters below create a streaking effect on the terrain. Could be a
    cool visual later on. float fresnel = GetFresnel(cameraPos,
    outVert.worldPosition.xyz, lightDir, normal, 4.0f, 64.0f); fresnel =
    min(fresnel, 1.0f); fresnel *= 0.9f;     

-   Player and other chars are blurry due to the paint filter. Skipping them in
    the filter may look better. This could be done with the stencil buffer.

-   World Render Target
        - Might just use simple, position based plant movement instead. Simpler
          and more mem-efficient

-   Some kind of perma growth mechanic that grows and prevents spread from
    taking its space

-   Rivers?

-   Enemies?

-   Some spread bomb, but it flattens the terrain as a result

-   Projectiles
    -   Needs target component to follow a given entity 
    -   Recieve input from somewhere 
    -   Apply velocity using new VelocitySystem instead of MovementSystem
    -   Separate component or apart of MovementComponent?

-   Hitbox system
    -   Hitboxes have flags that indicate behavior (RecieveKick, SpreadOnKick,
        DestroyOnKick, StopProjectileOnWorld, etc.)
    -   Some kind of behavior system based on those flags
    -   Remove radius from ProjectileComponent, maybe add radius to world
        collider?
    -   Rename to interaction bubble?

-   Need some way to sleep components

- For components that are a single variable, just use a general state and
  properties component

- Fire spread

- Cutting the spread for benefits ie. speed, stop fire

- Enemy that launches fireballs that rain down and destroy spread

- Some constant properties on holdable so they move with the property ie.
  spreading

- Should kick be a button or automatic

- Seed system
    - Need seeds to give spread
    - Seed bags that are necessary to hold a seed
    - Seeds are disperese with some kind of entity
    - Cutting spread gives seeds back
    - Each spread type have different properties

- When you slow down, certain parts of the world "unghost".
    - Basically shows hint, story of the is`land, etc.

- Each island level has its own story

- Some wind ability that magnets stuff toward you

- Should cut and kick be the same button?

- Spread that reflects the sky, shows soemthing

- Spread that lights up to reveal the dark

- Levels have pre-placed spread, cut and move the seeds

- Meteoric speed effect where if you go fast enough you can bump people hard
    - Crash into enemy to stun for a while, but removes your own speed

- Music bells

- Enemy that slowly follows you
    - Have an obstacle in the level that slow you down

- Level where you form terrain pits to round up object

- Mole that goes underground and modifies terrain
    - Player needs to modify terrain too to beat them

- Effect that only works on flat terrain. Probably on an enemy

- Enemy that stabs the world and pokes a hole through it
    - Some rounding quest with these present, keep other entities alive

- Badge that puts interval spawner on player, spawns something

- Reflection necessary to see things falling from the sky
    - Only reflects on flat terrain
    - Spread that reflects from straight above

- IMPLEMENT: Hover highlight like Mario Galaxy?
- Fall colored spread that grows under trees
    - Trees can be knocked down with meteor effect
    - Trees give some resource when dropped
    
- Interval spawning enemy that pops up and disappears in random spots

- Kick on ground = knockback (reverse grounded veloicty), maybe launch
    - Can have entity shock if stop effect is wanted
- Kick in air = throw 

- Wind waker style light and shadow colors (lerp to values)

- Bouncy ball projectile that has to be dodged (super low gravity and movement,
  high count)

- Tunicate squirter

- Level where tide rises and falls
    - Some stuff on high
    - Others on low
    - Different benefits for each

-   How to balance meteor, cut/hit, and pickup?
    -   Remove pickup?
    -   Make left trigger movement spread on hard press only
        -   Can also use top triggers for no spread
        -   Remove spread from ski, or hard press only?
        -   There might be value in keeping forced spread, need to test
    -   Cut/hit gives reverse knockback
    -   Meteor give no knockback, armor breaking
    -   Only meteor has targeting on projectiles
        -   See what happens when player is allowed to be target
        -   Some projectiles are meteorable, need a color indicator
        -   Have meteor reflect projectiles back to target
    - Cut forces you on a line path with little control, reflects?
        - Can exit and transfer velocity in any direction

- Kickable that forms wall in the air, if anything hits the wall, dead

- Attack that only shoots up from spread, have to cut

- Instead of seeds, use a meter with how much spread energy player has
    - Kinda like Rocket League boost meter
    - Cutting gives 1 meter back
    - Objects that distrubte meter based on condition, ie. meteor hit

- Spread spend sends player into sky meteor state
    - Full control rising
    - Limited control falling
    - Spread on launch, with hill?
    - Depress ground on land
    - OR
    - Remove spread on launch, with hill
    - Nothing on landing
    - Test both

- Ring a bell to go to next level
    - Lots of reverb

- Add some kind of action on hard turn

- Store world WVP matrix off by a few frames so it appears behind in time 

- Somwthing you hit in air

- Object that explodes nearly instantly on contanct, harms player
    - Player can pivot away to avoid

- World that swaps reveals based on where play leaped
    - Two leap maps
    - Each swaps on leap

- If there's artifcating on the modifiers, likely need to:
    - Increase updates per tick
    - Use double buffering

- Objects that activate when jumped off of
    - Give seeds
    - Modify world
    - Bigger spread
    - Temporary ability (magent)

- Mole that lifts ground whenever popped out
    - Hella big

- Why dynamic world is bad
    - Overcomplicates world generation
    - Restritive while also being over centralizing
    - Only a few use cases, limits the design of rest of game

- Since each entity has some spread meter, have them release the meter on death
  to pickup

- Spread meter is basically enemy HP

- Balloon to pop that give spread meter

- Enemies can break spread to gain meter

- Converts meter to ie. homing thing

- Meter particles falling from sky 

- Moving enemies that follow different paths ie. circle, line, zigzag

- Use heightmap only for terrain

- Add HP component, maybe store meter and when it runs out or reaches threshold,
  do an action

- Some way to stop captures as they happen, so seeds are left floating

- On seed touch ground, re-randomize bounce

=============================================================
- Need to rewrite rendering and resource code
    - Renderer puts stuff on screen
    - Resource manager loads resources and wraps them

- Have wrapper classes for each type of graphics piece
    - Keep the abstraction RELEVANT TO THE GAME
    - Vertex Buffer
        - Probably make the buffers per type
        - OR can have layouts pre-defined
        - Should meshes be their own object holding a Buffer?
        - Or should the meshes just include the buffers implicitly
    - Instance Buffer
    - Particle Buffer
    - Vertex Shader
    - Pixel Shader
    - Input Layout
    - Texture
    - Constant Buffers
    - Modifier Buffers
    - Rewrite with bgfx?
    - Some compute shader abstraction if necessary
        - Input buffer
        - Output buffer
        - Compute buffer
- What shoule be transparent:
    - Allocation
    - Deletion
    - Layout definition
    - Probably Constant Buffers
    - Swap chain

- API Goals:
    - Load meshes into buffers
    - Load animations and skeletal meshes
    - Load multiple meshes into a single model object
    - Render instances based on an instance buffer
    - Post process
    - Programmer defined constant buffers
    - Programmer defined input layouts
    - Render entities based on components
    - One class for all buffers, textures, etc.
    - Then each buffer holds a descriptor struct
    - Have resource setting in platform specific code, actual rendering in
      generic
- Sources: https://alextardif.com/RenderingAbstractionLayers.html
  https://www.gamedeveloper.com/programming/designing-a-modern-cross-platform-low-level-graphics-library
- Use typedefs for rendering objects and go from there
- Stay close to the actual rendering api
  =========================================
- Seed particle pickup

- Slide off/strong slopes

- Projectile ground sliding
    - Likely need to make a general grounding/friction system not apart of the
      projectile system ==========================================
- Should store the an array of intersections then process them in another
  function, rather than handling them straight in the intersection call
- Remove systems with more than one fucntion car
- Collision list
- Spawn list
- Store loaded entities in resource manager and copy instead of reconstructing
  from json
- Only use WICTextureLoader from git instead of whole DXTK
- Fix glm headers and only include necessary glm headres
    - Use glm forward header
